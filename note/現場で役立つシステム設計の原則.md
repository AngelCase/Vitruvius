○Value Object
数量などにint型をそのまま使うとintのとる範囲が広すぎて変な値が購入する可能性がある。そのため専用の型を用意してやって、コンストラクタなどで中身をチェックするのが良い。
他のメリットとして、全く種類の異なるオブジェクトを代入せずに済むと言うメリットがある。例えば、金額に対して数量を代入してしまうことがなくなる。
// 個人的には、独自クラスで溢れたコードを見るのは辛い気もする。なんでもかんでもvalue objectにするのではなくあくまで業務の関心事にとどめるべきな気がする。あるいは、独自に定義された型もプリミティブ型のように信用すればいいのか？

○value objectは不変にする
別の値が必要になったら別のオブジェクトを作成する。1つのオブジェクトを使い回すのは危険。
オブジェクトの生成時にオブジェクトの状態を完全に設定するやり方を完全コンストラクタと呼ぶ。

○コレクションオブジェクト
listやmapなどのコレクション型のデータだけを持ったクラス。
このようなクラスを作ることで、コレクション操作のロジックを閉じ込められる。例えば、要素数のチェックやループ処理など。
// よくわからない。要素数のチェックをする事の何が嬉しいのか？要素の範囲外を触ってしまっても何もエラーが出ないのを防ぎたいという事？それからループ処理もそんなに煩雑か？

○条件文をわかりやすくするためにメソッドに抽出する
// 説明変数に先に代入しておくのとどっちがいいんだろう？変数にしちゃうとスコープが広くなるからやめたほうがいいのかな？ただし、C++ならスコープをif文の中に限定できるけど。

○状態遷移のルールは列挙型でわかりやすく記述できる
まず、すべての状態を列挙型で宣言する。
そして、Mapで状態遷移のルールを記述する。遷移元をキー、遷移可能な状態のSetをバリューとして持たせる。
また、このやり方はいろいろ応用が効く。

○ドメインオブジェクト
データクラス、機能クラスで分けるのは良くない。オブジェクト指向ではそれらを1つのクラスにまとめるべき(ドメインオブジェクト)。データとそれに関連するロジックを同じクラスにまとめる。例えば、クラスは単にデータを返すだけではなく、それを加工して返すべきだ。そうすることによって同じ行動が違う場所に存在するのを防げる。例えば人の名前を保持するクラスだったら、苗字と名前をそれぞれそのまま返すのではなく、フルネームとして返すようなロジックを作る。

○オブジェクト指向ではボトムアップで設計していく
部分を作っていくことで段階的に全体を作っていく。そのため、データとロジックが一緒になったオブジェクトが作られていく。
逆に手続き型ではトップダウン。

○ドメインオブジェクトを見つけていくために、ヒト、モノ、コトで業務を分類していく
そして、コトに注目していくと全体を整理しやすい。なぜならコトとはヒトとモノの関係性であり、時間軸に沿って明確な前後関係を持つため。

○三層アーキテクチャのアプリケーション層は、参照と更新でクラスを分ける
参照系のサービスは副作用を持たないため安心して使える。
分割した後は、シナリオクラスでこれらのクラスを利用する。

○契約による設計と防御的プログラミング
契約による設計とは、サービスを利用する側とサービスを提供する側とでサービス提供の約束事を決めて設計をシンプルに保つ技法。
防御的プログラミングとは、サービスを利用する側が何をしてくるか分からないと言う前提で防御的なロジックを書く。しかしこの方法だと、無意味にコードが複雑になってしまうし、防御しきれない場合も往々にしてある。

○データベースにはNULLが入らないように心がける
そうでないとそれが必要な値なのかどうかわからない。できるだけNOT NULL制約を使い、どうしてもNULLを入れなければならないのならば別のテーブルにすることを検討する。

○データベースにカラムを追加するのではなく、テーブルを追加する
そうしなければ今までのプログラムを変更しなければならなくなるから。

○GETする対象のリソースの識別番号はクエリパラメータよりも、URIのパスで表現すべき

○POSTとPUTの違いは、POSTは識別番号をもらうのに対し、PUTは識別番号を指定する点
POST、books
PUT、books/1234
PUTはサーバ側のリソースの識別体系を事前に知っておく必要があり、その点において結合が密になる。ゆえにデータの登録はできるだけPOSTにすべき。