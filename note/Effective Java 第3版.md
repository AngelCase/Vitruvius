○何も指定されていないときのアクセスレベルはパッケージアクセス
つまり、現在のクラスと同じパッケージ内のクラスからのみアクセスできる。ただしインターフェースのメンバーはデフォルトで`public`。

○staticファクトリー
コンストラクタの代わりにインスタンスを返す関数を作る。メリットは以下の通り。
1、コンストラクタとは違って自由な名前をつけられる
2、新しいオブジェクトを返す必要がなく、既存のオブジェクトを使い回せる
3、戻り値の型の派生クラスを返せる
デメリットは以下の通り。
1、コンストラクタとは違って目立たない
2、staticファクトリーを使うという事はコンストラクタを`private`にすることが多い。だがそうなると派生クラスが作れない。

○インスタンス化を禁止するならコンストラクタを`private`にする

○コンストラクタのパラメータが増えすぎた時はビルダーを使う
必須のパラメータはビルダーのコンストラクタの引数にしておいて、デフォルト値があるパラメータはメソッドチェーンでセットする。
また、パラメータが少なかったとしても、ビルダーを使って損はない。なぜなら、後々パラメータが増える可能性があるから。

○ファイナライザとクリーナーを避ける
C++のデストラクタとは全然違うもの。オブジェクトが到達不可能になってからこれらが実行されるまでの時間は任意の長さになりうる。

○try-finallyよりtry-with-resourcesを使う

○共変戻り値型
オーバーライドしているメソッドの戻り値は、元のメソッドの戻り値のサブタイプにできる。

○チェック例外、非チェック例外
チェック例外は正しいプログラムを書いたとしても起こり得る例外。例えばファイルの破損やデータベースの不具合。そのためキャッチする必要がある。
一方非チェック例外は正しくプログラムを書けば起こらない例外。

○staticインポート
static変数や staticメソッドをクラス名を指定せずに使用できるようにする機能。

○javaでは抽象クラスではなくインターフェイスを選ぶべき
クラスだと複数継承できないため。
インターフェースと抽象クラスの長所を組み合わせる方法として骨格実装がある。これは、インターフェースの中で重要な部分だけを実装した抽象クラスである。
骨格実装を作る手順は次の通り。まず、インターフェイス内の基本操作メソッドを見つけ出す。これは他のメソッドを実装するためのものであり、骨格実装においては抽象メソッドのまま。次に、基本操作で実装できるメソッドはインターフェース内でデフォルトメソッドとして書く。残りを骨格実装で書く。残ったものがなければ骨格実装は必要ない。

○定数だけを提供するようなインターフェイスは作るべきではない
それをするぐらいだったら普通にクラスの中に定数を書く。あるいはインスタンス化不可能なクラスで定数を提供する。

○たいていの言語では数値リテラルに区切り文字を入れられる
javaの場合だとアンダースコア。5桁以上の数値を扱う場合1000の正のべき乗、負のべき乗ごと(3桁ごと)に入れると見やすくなる。
ちなみにC++の場合シングルクォーテーション。

○メンバークラスを作るならstaticのメンバークラスにする
非staticだと、エンクロージングクラス(それを包んでいる側のクラス)との関連付けがされ、メモリや時間のコストがかかる。そのため、エンクロージングクラスへの参照が必要ない場合は staticにする。

○ワイルドカード`<?>`と型パラメータ`<T>`
型パラメータはクラスやメソッドの宣言に使う。ワイルドカードは任意の型を入れられるということを示し、引数や変数、戻り値に使う。

○非境界ワイルドカード型
`List<?>`にはどんな`List`も代入できる。`List<String>`も`List<Integer>`も。
ただし非境界ワイルドカード型には制限がある。前提として`Sample<T>`クラスを`Sample<?> sample = new Sample<String>();`でインスタンス化したとする。この時、メソッド`T get()`の戻り値Tは`Object`型になる。また、メソッド`set(T val)`の引数`val`は`null`しか取れない。

○原型を使わないこと
`List<E>`に対して`List`を原型と言うが、これを使ってはいけない。なぜなら、原型には何でも入れることができてしまうから。
代わりに`List<?>`のような非境界ワイルドカード型を使うべき。
原型を使わなければならない場面は、クラスリテラルList.classとinstanceof演算子に使う時。

○配列よりもリストを選ぶ
`Object[]`には好きな型の値を入れられるため、整数を入れた後に文字列を入れるようなコードを書いても、コンパイル時にエラーは出ず、実行時にエラーが出る。一方、`List<Object>`は整数や文字列をそもそも入れることができないため、コンパイル時にエラーが出る。

○引数に境界ワイルドカードを使うとAPIの柔軟性が向上する
[[Java_PECS]]

○非境界型パラメータと非境界ワイルドカードならワイルドカードの方を使うべき
一般に、型パラメーターがメソッド宣言中に1度しか現れないのならそれをワイルドカードに置き換える。

○`enum`の定数ごとに異なる操作をしたい場合、定数固有メソッド実装が使える
例えば四則演算の場合に有用。`enum`型の中で抽象メソッドを宣言しておき、それを定数ごとに具象メソッドでオーバーライドする。
この方法の問題点に、`enum`定数の間でコードの共有が難しいという点が挙げられる。この問題への対処の方法としては戦略`enum`を移譲するのがよい。`enum`の中に、さらに戦略`enum`を定義することで、`switch`文よりも柔軟になる。

○`enum`の序数の代わりにインスタンスフィールドを使う
`enum`は定義された順番によって序数を持っているが、これを使うのはあまり良くない。なぜならば、順番を変えたら壊れてしまうし、飛び飛びの値を定義すると序数と噛み合わなくなってしまうため。そのため、フィールドとして値を持つのが良い。

○ラムダの短所は名前とドキュメンテーションが足りない点
計算が自明じゃなかったり、計算が四行を超えているならラムダにすべきではない。

○関数型インターフェイスは自分で作らなくても標準のものを使えば良い
基本的な6つのインターフェイスを覚えれば後は簡単な命名規則なので他のインターフェイスは導き出せる。
operator、引数と戻り値の型が同じ
predicate、引数を受け取り`boolean`を返す
function、引数と戻り値の型が異なる
supplier、引数を受け取らず戻り値を返す
consumer、引数を受け取り何も返さない
標準の関数型インターフェイスを使わずに自分で作るべき場面は、広く使われていて名前が特性を説明している場合などがある。

○ボクシングされた基本データよりも基本データ型を選ぶ
`==`で同一性比較が行われてしまったり、基本データ型と比較したときにアンボクシングが行われ、パフォーマンス低下が起きてしまったりするため。

○文字列結合演算子を使うのではなく`StringBuilder`を使う
文字列結合演算子はパフォーマンスがひどい。

○チェック例外は、例外への対処を強制させる場合にのみ使う
過剰にチェック例外を使うとそのメソッドを使うのが苦痛になる。

○例外は必要に応じて翻訳する
下位レイヤーから来た例外をそのままスローするのではなく、上位レイヤーで説明可能な例外をスローすべき。でなければ、上位レイヤーを実装の詳細で汚染してしまう。
ただし、例外翻訳を使う前に、上位レイヤーにおいて例外に対処することを優先しそれが不可能な場合のみ例外翻訳を行う。

○マルチキャッチ
例外型をパイプを挟んで並べることで、複数の例外を1つのcatchで処理できる。
