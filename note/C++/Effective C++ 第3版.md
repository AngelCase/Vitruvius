○クラス定義内での「宣言時の初期化」は、以下のような整数型定数にしか許されていない。
```c++
class GamePlayer {
private:
    static const int NumTurns = 5;
…
};
```
なのでそれ以外の場合はソースの方で初期化をする必要がある。
また、整数型定数はクラス定義内で初期化できるが、ソースの方で初期化した場合、その定数の値をクラス内で使えなくなってしまう。その場合、enumハックという方法がある。
```c++
class GamePlayer {
private:
    enum { NumTurns = 5; }
    int scores[NumTurns];
…
```
まぁわざわざこんなことをしなくても整数だったらクラス内で初期化すればいいが。

○イテレータや関数オブジェクトは値渡し前提でデザインされているので値渡しすれば良い。参照渡しよりも効率的。

○継承よりも合成。継承はポリモーフィズムには良いが単に同じ機能を持たせたいからと言う理由で使うべきではない。なぜなら、派生クラスでバグが起きたときに基底クラスも見に行かなければならないから。

○カプセル化の観点ではpublicもprotectedも変わらない。protectedなデータメンバを消すと、それを使っている派生クラスの全部で修正が必要になるから。

○メンバ関数よりメンバでもフレンドでもない関数を使おう。メンバ間数が増えれば増えるほどprivateなデータにアクセスできる関数が増えることとなり、カプセル化が弱まる。
→これは正直疑問。そのクラスに関係のある関数だったらそのクラスの中にあったほうがいいと思うんだけど、インタフェース的な意味で。

○純粋仮想関数は、複数の関数宣言を使えば定義を持てる。これは安全な仮想関数の実現に利用できる。
例えば、派生クラスを作る際に仮想関数をオーバーロードし忘れてしまい、意図せずに基底クラスの仮想関数の定義が呼ばれてしまうということを防げる。
実際の利用時には、以下のようなコードで純粋仮想関数の定義を呼べる。
基底クラス::純粋仮想関数();

○privateな仮想関数をオーバーライドできる。派生クラスからは当然呼び出せないが、基底クラスでの挙動を派生クラスで変えられる。

○テンプレート内でネストされた依存名を使うときには頭にtypenameをつける必要がある。ここでネストされた依存名とは、クラスの内部で定義された型のことで、この本独自の用語。例えば以下のC::const_iterator。
```c++
template<typename C>
void func(const C& c)
{
    C::const_iterator; // コンパイルエラー
    typename C::const_iterator; // OK
}
```