桁数が関係してくると出てくる。
あるいは、二分探索もデータサイズの桁数と関係があるから出てくる。
## 二進法展開 O(logn)
整数nを二進法で表したとき何個の例があるか数える。
```c
int bit_count(int n) {
    int count = 0;
    while (n > 0) {
        if (n % 2 == 1) ++count;
        n /= 2;
    }
    return count;
}
```
$n=2^k$のときループ回数は$k+1$（$=log_2{n}+1$）回となる。
## ナベアツ O（logn）
正の整数nが3の倍数か、または3の付く数字であるかどうかを判定。
```c
bool is_aho(int n) {
    if (n % 3 == 0) return true; // 3 の倍数か
    while (n > 0) {
        if (n % 10 == 3) return true; // 3 が付くか
        n /= 10;
    }
    return false; // 3 の倍数でなければ、3 も付かない場合
}
```
3の倍数判定は$O(1)$だが、3がつくかどうかは桁数依存なので$O(log_{10}{n})$となる。
ちなみに、対数の底の違いは以下の「底の変換公式」より無視できる。
$log_{10}n=\dfrac{log_2{n}}{log_2{10}}$
## 二分探索 O(logn)
サイズnの配列aのindexのうち値v以上となる最小のindexを返す。
```c
int binary_search(int v) {
    /* 目的の index は [left, right) のどこかにある */
    int left = -1;
    int right = (int)a.size();

    while (right - left > 1) {
        int mid = left + (right - left) / 2;

        /* a[mid] と v との大小関係に応じて候補区間を左右半分に分ける */
        if (a[mid] >= v) right = mid; // 候補区間を [left, mid) に
        else left = mid;              // 候補区間を [mid, right) に
    }

    /* left は条件を満たさない最大の値、right は条件を満たす最小の値になっている */
    return right;
}
```
最初は
- left = -1
- right = n
となっていて、その広さはright - left = n + 1。
だが、ループが回るたびに**right - leftの値は半分**になっていく。
そしてright - left = 1となるまでループする。

ループ回数は二進法展開とほぼ同じ議論になり、$O(log n)$回。
このように、ループが回るたびにある量$x$の値が半分になっていくとき、
ループ回数は$O(log n)$回になる。

## マージソート O(nlogn)
アルゴリズムについては[[クイックソートとマージソート]]を参照。

マージソートの計算量を$T(n)$とすると、以下の漸化式が成り立つ：
$T(1) = O(1)$
$T(n) = 2T(n/2) + O(n) (n > 1)$
サイズ$n$の問題を半分ずつに分割して解くので左右合わせて$2T(n/2)$、
マージ処理が$O(n)$。

細かい証明は参考資料に譲るが、
こういった漸化式は$2T(n/2)$の部分で出てくる定数が等しいので
$T(n) = O(n \log n)$となる。

もし$2T(n/3)$とかだったら
$T(n) = O(n)$となる。

## クイックソート 平均O(nlogn)、最悪O(n^2)
アルゴリズムについては[[クイックソートとマージソート]]を参照。

マージソートと似たような考え方ができるが、
平均$O(n \log n)$だが、最悪$O(n^2)$となる。
最悪はめちゃくちゃデータが偏っていて
配列を1つずつ縮めながら（$n$回）毎回全要素（$n$要素）を見なきゃいけない時。
つまり、半分に割って効率よくしたいのに、片方の要素が毎回1か0しかない時。
つまり、以下のような昇順ソートと降順ソートをくっつけたパターン。
```c
step1
[1,2,3,4,3,2,1]
↓
[1,2,3,1,3,2,4]
（右半分は[]）

step2
[1,2,3,1,3,2]
↓
[1,2,2,1,3,3]
（右半分は[3]）

step3
[1,2,2,1]
↓
[1,1,2,2]
（右半分は[2]）
```

## 参考
[計算量オーダーの求め方を総整理！ 〜 どこから log が出て来るか 〜 - Qiita](https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0)