## ソフトアーキテクチャの目的
ソフトウェアアーキテクチャの目的は、
求められるシステムを構築・保守するために必要な人材を最小限に抑えることである。

## 汚いコードを書くのは遅い
汚いコードを書けば短期的には速くなると考えている開発者は多いが、
実際には汚いコードを書く方がクリーンなコードを書くよりも常に遅い。

## ソフトウェアシステムの提供する2つの価値
ソフトウェアシステムは2つの異なる価値を提供する。
1つは振る舞い。もう一つは構造。
振る舞いとは思い通りに動くことであり、構造とは変更できることである。

## プログラミングの3つのパラダイム
プログラミングのパラダイムには以下の3つがある。
- 構造化プログラミング(gotoでのジャンプを使う代わりに、ifやwhileを使う)
- オブジェクト指向プログラミング
- 関数型プログラミング
これらはどれも新しい機能を提供するものではなく、
プログラマーに対して制約を課すものである。
これら3つが、アーキテクチャの3つの大きな関心事に対応している。
その3つとは、コンポーネントの分離、データ管理、機能である。

## SOLID原則
### 単一責任の原則
モジュールを変更する理由は、たった1つだけであるべきである。
つまり、アクター(ユーザやステークホルダー)が異なるコードは分割すべきであり、
処理が同じだからといってまとめてはならない。
誤解されがちな解釈が「どのモジュールもたったひとつのことだけを行うべき」というものだが、
これが適用されるのは、関数など最下位のレベルでありSOLID原則とはまた別。
### オープン・クローズドの原則
ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである。
コンポーネントAが、コンポーネントBの変更から保護されるべきならば、
コンポーネントBからコンポーネントAへ依存すべきである。
### リスコフの置換原則
派生クラスを使っている時、それを基底クラスに置き換えても振る舞いが変わらないこと。
簡単に言うと、派生クラスは基底クラスの振る舞いを変えてはならない。
### インターフェイス分離の原則
必要ない部分に依存しないようにすること。
例えば、ユーザクラスが操作クラスを使っていて、
操作クラスにユーザクラスで扱っていない部分がある場合、
必要な部分だけをインタフェースで切り出すべきである。
そうしないと関係ない部分が変更されたときに予期しないトラブルが起きる可能性がある。
### 依存関係逆転の原則
システムを柔軟にするためには、抽象を参照すること。
ただ、だからといって全てを抽象にするのは間違っている。
あくまで変化しやすい部分に依存しないようにしたい。例えば開発中のモジュールなど。
また、抽象は変更を少なくすべきである。
なぜなら実装を変えてもインターフェースは変わらないが、
インターフェイスを変えたら実装を変えなければならないため。

## コンポーネントの凝集性に関する3つの原則
### 再利用・リリース等価の原則
再利用する単位とリリースする単位は同じになる。
### 閉鎖性共通の原則
同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。
それらが異なる場合は、別のコンポーネントに分ける。
単一責任の原則をコンポーネント向けに言い換えたもの。
### 全再利用の原則
コンポーネントのユーザに対して、実際には使わないものへの依存を強要してはいけない。
例えばコンテナクラスとそれに対応するイテレータはまとめて再利用すべきものなので、
同じコンポーネントにまとめておくべき。
これは、インターフェース分離の原則を一般化したものである。
これらはどちらも「不要なものには依存しないこと」とまとめられる。
(感想)原則の名前が分かりにくい。最初の説明の1文を名前にすべきだと思う。

## 非循環依存関係の原則
依存関係がループしてはいけない。
依存関係があるという事は、
つまりどこか変更したらそれに依存している部分を変更しなければならないということである。
もしもループが存在すると当然困ることになる。
ループを排除したければ、インターフェイスを挟むか、新しいコンポーネントを間に挟む。

## 安定依存の原則
より安定しているものに対して依存すること。
不安定なものに依存してしまうと、1つを変更したときに連鎖的に変更が発生してしまう。
また、安定度はそれがいくつのコンポーネントに対して依存しているかで定量化できる。
不安定なコンポーネントに依存している状況を避けたい場合は、間にインターフェースを挟む。
(感想)安定度をファンアウト/(ファンアウト+ファンイン)で定式化しているが、
これはあくまで説明のための簡略化した式であって、
実際にこれだけで判断するのは不正確だと思う。
依存対象がどれだけ安定しているかによっても変動する気がする。
つまり、不安定なものに依存している場合はより不安定になるし、
安定したものに依存している場合はより安定していると判断されるべきだと思う。

## 安定度・抽象度等価の原則
安定度の高い(つまりたくさん依存されている)コンポーネントは、抽象度を高くなるべきである。
なぜならそうでなければ変更できないから。
したがって、コンポーネントの安定を高くするのであれば、拡張できるようにインターフェースと抽象クラスで構成すべき。

## アーキテクチャを決めるときは方針だけ決める
アーキテクチャを決定する際には、方針だけを決めて詳細は決定しない。
方針とは、つまりビジネスのルールや手順である。
詳細とはデータベースやウェブサーバーなど。
こうすることによって、重要ではない詳細に選択肢を残しておくことができ、柔軟性を持たせられる。
最初に詳細を決めてしまうと、後から判断のミスに気づいて後悔することになるかもしれない。MySQLを使うと最初に決めたのに、
後から実はデータベースが要らなかったことに気づくかもしれない。

## 重複するコードを共通化するか？
ソースコードの重複があった時、それを共通化するかどうかは熟慮を要する。
例えば画面構成が同じ2つのユースケースがあったとする。
この時、ソースコードを共通化したくなるかもしれないが、
これは本当に重複しているわけではなく、偶然重複しているだけだろう。
つまり時間が経てば、それぞれの画面は少しずつ違ったものになる可能性が高い。
したがってこの場合は共通化してはならない。

## Humbleパターン
テストしやすい振る舞いとテストしにくい振る舞いに分割する。
例えば画面はテストしにくい振る舞いなので、
ここには何のロジックも書かない(humble、質素なオブジェクト)。
そのかわり、プレゼンターにロジックを書く。
画面はプレゼンターから受け取ったデータをそのまま出力するだけである。
文字を赤くしなければならないのなら、赤色フラグを渡す。
通貨記号をつけなければならないのなら、そのフォーマットはプレゼンターが行う。

## フレームワークを使う際の注意
フレームワークを使うことに問題はないが、アーキテクチャの円の中心に結合させてはいけない。
後からフレームワークを変えたくなったり、
アップグレードが望まない方向に進んだりするかもしれない。
どうしても使わなければならないのなら、プロキシを用意すること。

## （全体を通しての感想）
(感想) アーキテクチャの本質とはいかにして変更するかということなんだ。
この本で説明されていたのは、どうやって変更しやすくするのか、
どこを変更しやすくするべきかだと思う。