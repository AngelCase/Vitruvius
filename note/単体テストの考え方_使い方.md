## 単体テストは資産ではなく負債
テストケースが多いほど良いと思っている開発者が多く存在するが、その考えは間違っている。なぜなら、コードは資産ではなく負債だから。テストコードもプロダクションコードと同じようにバグに対して脆弱であり、保守を必要とする。

## 網羅率を高めることを目標にしてはならない
網羅率を目標とするのではなく、テストが十分に行われていないことを示すためだけに使わなければならない。
テスト網羅率が低いことはテストスイートの品質の低さを示すが、それが高くてもテストスイートの品質が高いことにはならない。
例えば、以下のテストコードのコード網羅率は簡単に計算できる。
```c#
public static bool IsStringLong(string input)
{
	if (input.Length > 4)
		return true;
	return false;
}

public void Test()
{
	bool result = IsStringLong("abc");
	Assert.Equal(false, result);
}
```
総行数は5行（波括弧も行数に加えるため）、テストコードによって実行される行数は4行であるため4/5 = 0.8 = 80%。
しかし、以下のようにリファクタリングするとコード網羅率は100%に変わってしまう。
```c#
public static bool IsStringLong(string input)
{
	return input.Length > 5 ? true : false;
}
```
分岐網羅率が高ければこのようなリファクタリングには影響されず、算出することができるが、分岐網羅率の高さもテストスイートの品質の高さを示すものにはならない。なぜなら、テスト内で何も検証せずプロダクションコードを呼び出しているだけでも網羅率は上がってしまうため。

## 優れたテストスイートの特徴
優れたテストスイートには次のような特徴がある。
- テストすることが、開発サイクルの中に組み込まれている。
- コードベースの特に重要な部分のみがテスト対象となっている。
- 最小限の保守コストで最大限の価値を見いだすようになっている。

## 古典学派とロンドン学派
古典学派とロンドン学派の違いは、テストケースを隔離するか、コードを隔離するか。
そのため、古典学派ではテストケースの分離のためにモックを使い、ロンドン学派ではテスト対象クラスからそれ以外のクラスを分離するためにモックを使う。
それぞれの学派で「単位」の認識が異なっており、ロンドン学派は1単位のコード、古典学派は1単位の振る舞いと捉えている。

## 統合テストとE2Eテスト
統合テストとE2Eテストの違いは、統合テストは一個か二個のプロセス外依存を扱うのに対し、E2Eテストはエンドユーザーの視点でシステムを検証するため、ほぼ全てのプロセス外依存を扱う点。

## 準備Arrange、実行Act、確認Assert
テストの構造にはAAAパターンと呼ばれるものがある。これは、準備Arrange、実行 Act、確認 Assertの3つのフェーズで構成されるパターンである。

### 準備
準備フェーズは往々にして長くなりがちである。準備フェーズのコードをテストケース間で共有するのに有用なパターンとして、オブジェクトマザーと呼ばれるパターンと、テストデータビルダーと呼ばれるパターンがある。

### 実行
実行フェーズが2行以上になる場合、設計に問題がある可能性がある。なぜなら1つのことをするために、2つ目のメソッドを呼び出すことを知っていなければならないから。
ただし、ユーティリティやインフラに関するコードだと2行以上になることもあり得るので、常に1行のみにすることを強制すべきではない。あくまで、複数行の実行フェーズがある場合は、カプセル化が破綻していないことを必ず確認するようにする。

## SUT（System Under Test)
テスト対象システムと、その依存の違いが明確にわかることが重要である。そのためテスト対象システムにはsut(System Under Test)と名前をつける。
(感想)sutだと略しすぎていて、この本を読んだ人としか理解を共有できない。targetとかがよいのでは。

## テスト・フィクスチャ
テスト実施前に固定された(fixed)状態に毎回なっているオブジェクト。

## 準備フェーズのロジックを安易に共通化しない 
準備フェーズのロジックが重複しているからといって安易にセットアップ関数に切り出してはいけない。
理由は2つある
- あるテストケースで変更があった場合、もう片方のテストケースが影響を受けてしまうため
- テストケースの読みやすさを損なってしまうため。
より良い方法としては、共通的に利用するテストフィクスチャーの準備に関するコードをプライベートなファクトリーメソッドに定義すること。
```c#
public class CustomerTests
{
	// 在庫が十分にある場合、購入は成功する
	[Fact]
	public void Purchase_succeeds_when_enough_inventory()
	{
		Store store = CreateStoreWithInventory(Product.Shampoo, 10);
		Customer sut = CreateCustomer();

		bool = success = sut.Purchase(store, Product.Shampoo, 5);

		Assert.True(success);
		Assert.Equal(5, store.GetInventory(Product.Shampoo));
	}

	// 在庫が十分にない場合、購入は失敗する
	[Fact]
	public void Purchase_fails_when_not_enough_inventory()
	{
		Store store = CreateStoreWithInventory(Product.Shampoo, 10);
		Customer sut = CreateCustomer();

		bool success = sut.Purchase(store, Product.Shampoo, 15);

		Assert.False(success);
		Assert.Equal(10, store.GetInventory(Product.Shampoo));
	}

	// 指定した在庫を抱える店を作成する
	private Store CreateStoreWithInventory(Product product, int quantity)
	{
		Store store = new Store();
		store.AddInventory(product, quantity);
		return store;
	}

	// 顧客を作成する
	private static Customer CreateCustomer()
	{
		return new Customer();
	}
}
```
(感想)ファクトリーメソッドを使う際の注意として、結局そのファクトリーメソッドが見やすくなければ意味がない。それぞれの引数に何が入っているのかが明示的になるように意識する。

## テストメソッドに名前をつけるときの指針
厳格な命名規則に縛られないようにする。
開発者以外のドメインエキスパートにどのような検証するのかが伝わるような名前にする。
例えば、`sum_twoNumbers_returnSum`だと開発者に寄り過ぎている。
`sum_of_two_numbers`であれば非開発者でも理解しやすい。
英語の場合はアンダースコアを使って単語を区切るようにする。テスト名は名前が長くなりやすいので、こうすることによって、可読性を上げる。

## テストメソッド名にテスト対象のメソッド名を入れないこと
テスト対象のメソッド名をテストメソッド名に含めるべきではない。なぜなら、単体テストはコードをテストしているのではなく、アプリケーションの振る舞いをテストしているから。
ただし例外もあり、それはユーティリティ系のコードをテストする場合。ユーティリティ系のコードにはビジネスロジックが含まれておらず、その振る舞いは単純な補助的機能でしかないため。

## 良い単体テストの4本の柱
良い単体テストを構成するものとして、次の4本の柱がある。
- 退行に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ
これらのうち最も優先すべきはリファクタリングへの耐性と、保守のしやすさ。残りの2つはトレードオフになる。

## テストを書く必要のないケース
1行で書けるような取るに足らないコードにテストを書く価値はない。
```c#
public class User
{
	public string Name { get; set; }
}
```

## リファクタリングへの耐性
リファクタリングへの耐性とは、リファクタリングをおこなったとしても、テストが落ちないこと。正当な振る舞いなのにテストが落ちると、開発者がテスト結果を無視したり、リファクタリングをする気が失せたりする。
問題ないのにテストが失敗する偽陽性を防ぐためには、テストをテスト対象の詳細な実装から切り離し、観察可能な振る舞いに目を向けること。つまりテスト対象をブラックボックスとして扱うこと。

## 悪いホワイトボックステストの例
本気のホワイトボックステストに笑ってしまった。ソースコードの文字列の検証。
```c#
// MessageRendererクラスが正しく実装されている
[Fact]
public void MessageRenderer_is_implemented_correctly()
{
	string sourceCode = File.ReadAllText(@"[path]\MessageRenderer.cs");

	Assert.Equal(@"
public class MessageRenderer : IRenderer
{
	public IReadOnlyList<<IRenderer> SubRenderers { get; }

	public MessageRenderer()
	{
		SubRenderers = new List<IRenderer>
		{
			new HeaderRenderer(),
			new BodyRenderer(),
			new FooterRenderer() 
		};
	}

	public string Render(Message message) { ...略 }
}", sourceCode);
}
```
しかし、これはテスト対象のコードの中で何の関数が呼ばれたかをテストするのと同じ。なぜなら、どちらもテスト対象のコードに対して変更を加えるとテストが失敗するから。

## 不要なテストケースは消す
テストケースを含めた全てのコードは負債である。
そのため、テストケースが価値を持たなければ消さなくてはいけない。

## ブラックボックステスト > ホワイトボックステスト
ホワイトボックステストよりも、ブラックボックステストを選択すること。
ホワイトボックステストはコードの詳細まで見るため、ブラックボックスでは見つけられないようなバグを検出できるが、リファクタリングすると、すぐに壊れてしまう。

## ホワイトボックステストの使いどころ
テストの分析の際には、ホワイトボックステストの手法を用いることができる。例えばコード網羅率を計測するツールを用いて、まだテストされていない場所を発見できる。

## モックとスタブの違い
### モック
テスト対象システムからその依存に向かって行われる「外部に向かう」コミュニケーションを模倣する。つまり値を返さない操作。
### スタブ
依存からテスト対象に向かって行われる「内部に向かう」コミニケーションを模倣する。つまり依存からのデータ取得。
スタブとのコミュニケーションは検証してはならない。なぜならばそれは最終的な結果ではなく、最終的な結果を見いだすための一過程に過ぎないから。

## 実装の詳細を漏洩しているコード
1つの目標達成するために複数のメソッドを呼び出す必要がある場合、そのクラスは実装の詳細を漏洩しているといえる。
以下はユーザの名前を変えるのに2つの操作を行わなくてはならない例。
```c#
string normalizedName = user.NormalizeName(newName);
user.Name = normalizedName;
```

## モックの使いどころ
モックを使って良いのはシステム間コミュニケーションの場合で、かつそのコミュニケーションによる副作用が外部から観察できる場合だけ。システム内のコミュニケーションの確認にモックを使うとテストが壊れやすくなる。

## 単体テストの3つの手法
単体テストには次の3つの手法がある。
- 出力値ベーステスト、出力された値を検証する
- 状態ベーステスト、テスト対象の状態を検証する
- コミュニケーションベーステスト、テスト対象とその協力者、オブジェクトとのあいだで行われるコミニケーションを検証する
リファクタリングへの耐性と保守のしやすさの観点で見ると、出力値ベーステストが最も良く、コミュニケーションベーステストが最も悪い。そのため全てにおいて出力値ベーステストを用いるように努めるべき。

## 関数型アーキテクチャ
関数型アーキテクチャでは副作用をビジネスオペレーションの最初や最後にもっていくことで、ビジネスロジックと副作用を分離しやすくする。
ビジネスロジックと副作用の分離は次の2種類のコードに分離にすることで行われる。
- 決定を下すコード、数学的関数を使って書かれた副作用を起こさないコード
- 決定に基づくアクションを実行するコード、下された決定を観察可能な振る舞い(データベースの操作やメッセージの送信)に変換するコード

## 関数型アーキテクチャのトレードオフ
関数型アーキテクチャを採用するとパフォーマンスは低下し、コードの量も増えるが、そのかわり保守はしやすくなる。プロジェクトに採用する際は、このトレードオフを意識すること。

## コントローラとドメインクラスの分離
ビジネスロジックに関するコードと連携の指揮に関するコードを分離する事は極めて重要。
コントローラは、多くのオブジェクトを指揮していても、複雑さを持ってはならない。
ドメインクラスは、その逆となるようにしなくてはならない。
現在広く知られているパターンの多くはこの分類を目的にした設計になっているものが多い。

## 状態の変化をドメインイベントとして持つ
ドメインモデルの状態の変化をドメインイベントとして格納しておけば、コントローラから状態の変更を追跡する責務を取り除ける。
```c#
public class User {
	...略

	// ドメインイベントのコレクション
	public List <EmailChangedEvent> EmailChangedEvents { get; private set; }

	public void ChangeEmail(string newEmail, Company Company)
	{
		...略

		// メールアドレスの変更があったことを伝えるドメインイベントの追加
		EmailChangedEvents.Add(
			new EmailChangedEvent(UserId, newEmail));
	}
}

public class UserController
{
	public string ChangeEmail(int userId, string newEmail)
	{
		...略

		user.ChangeEmail(newEmail, Company);

		...略

		// ドメインイベントをメッセージに変換して送信する
		foreach (var ev in user.EmailChangedEvents)
		{
			_messageBus.SendEmailChangedMessage(
				ev.UserId, ev.NewEmail);
		}

		return "OK";
	}
}
```

## 単体テストと統合テストのテスト対象
## 対象コード
単体テストではドメインモデルやアルゴリズムを検証し、統合テストではコントローラを検証する。
取るに足らないコードは検証する必要がない。過度に複雑なコードはリファクタリングして、ドメインモデルとコントローラに分ける。

### 対象ケース
一般的に、単体テストは、ビジネスシナリオにおける異常ケース(事項がエラーで終わる場合)をできるだけ多く検証するのに対し、統合テストは最長のハッピーパス(すべてのプロセス外依存を経由しつつ正常に終わる実行経路)と、単体テストでは検証できないすべての異常ケースを検証することが適切だと考えられている。

## モックするか否かは管理下にあるかで決める
統合テストにおいてモックに置き換えるか否かは、それがテスト対象システムの管理下か否かで決まる。
管理下にある依存とは、アプリケーション外部から見ることができない依存である。例えばテスト対象のアプリケーションしかアクセスしないデータベースなどがある。これは実装の詳細であるためそのまま使用する。
管理下にない依存とは、アプリケーションの外部から振る舞いとして観察可能なものである。例えばメールサービスなどがある。このような依存はモックに置き換える。

## 実装クラスが1つなのにインタフェースを作る理由
実装クラスが1つしかないのにインターフェイスを作る理由は、モックを作れるようにするため。そしてモックを使うべきは管理下にない依存に対してのみである。そのため、管理下にない依存に対してのみインターフェイスを使用すること。
実装クラスが1つしかないのにインターフェースを用意するのはYAGNI原則(現時点において必要でない機能に対して時間を費やすべきではないと言う考え)に反している。

## ログ出力のテスト
ログ出力が非開発者にも見える場合(つまり観察可能な振る舞いである場合)はログ出力もテストすべきである。

## アンチパターン環境コンテキスト
環境コンテキストと呼ばれるような、依存関係が見えにくくなるような方法を使ってはならない。
以下の例では静的なメソッドを使っているため依存関係が見えにくい。
```c#
public class User
{
	// 静的なメソッドを介してILogger型のインスタンスを取得し、
	// そのインスタンスをプライベートなフィールドに格納する
	private static readonly ILogger _logger =
		LogManager.GetLogger(typeof(User));

	public void ChangeEmail(string newEmail, Company company)
	{
		_logger.Info(
			$"Changing email for user {UserId} to {newEmail}");

		...略

		_logger.Info($"Email is changed for user {UserId}");
	}
}
```
このような依存の取得のやり方はアンチパターンである。依存が隠れ、変更が難しくなり、また、テストがより難しくなる。
すべての依存は、コンストラクタメソッドの引数を経由して明示的に注入されるようにすべき。

## （発見）for文の中身だけを切り出すときの命名
この本では、同じ名前にして引数を変えることでオーバーロードしている。
```c#
public void Dispatch(List<IDomainEvent> events)
{
	foreach (IdomainEvent ev in events)
	{
		Dispatch(ev);
	}
}

public void Dispatch(IDomainEvent ev)
{
	...略
}
```

## モックに置き換える際のポイント
コンポーネントをモックに置き換える際は、できるだけアプリケーションとアプリケーション外の境界に近いものを置き換えるようにする。
そうすることで2つのメリットがある。
- テスト時に呼び出されるコードの数が増え、リグレッションへの保護が強まる
- テストの対象が外部から観察できる振る舞いになることで、リファクタリングへの耐性が強まる

## モックの呼び出し回数を確認すること
モックに対して行われた呼び出しの回数を常に確認すること。想定する呼び出しが行われている事は当然確認するが、想定しない呼び出しが行われていないことも確認するのが重要である。

## 外部ライブラリに対するモック
外部ライブラリを直接モックに置き換えるのではなく、そのライブラリに対して作成したアダプタに対してモックを作成する。ただし、あくまでモックすべきは管理下にない依存であるため、管理下にない依存にライブラリがたどりつかない場合はそもそもモックする必要は無い。

## データベースの単位作業
データベース更新時の不整合を防ぐ方法としてトランザクションがあるが、単位作業と言う方法がさらに優れている。
単位作業はデータ変更をまとめて行うパターン。トランザクションの時間を短くでき、データベースへの呼び出し回数も減らせる。

## テスト実行後に他のテストに影響を与えないために
統合テストを実行した後に残ったデータが、他のテストケースに影響を与えないようにするためにいくつか選択肢がある。
各テストケース実行前に、バックアップからデータベースを復元させる。問題点は時間かかること。
テストケースの実行後にデータの後始末をする。問題点はテストケースが途中で中断した場合、後始末が正常に行われない場合があること。
テストケースを1つのデータベーストランザクション内で行い、最後にコミットせずにロールバックする。問題点は1つのトランザクションがテストケース内で使われ続けること。本番環境とテスト環境で行っていることが乖離してしまう。
テストケースの実行前にデータの後始末を行う。これらの中では、この方法が最も優れている。

## プライベートなメソッドはテストしないこと
プライベートなメソッドをテストしてはならない。これをしてしまうと、テストが実装の詳細と結びついてしまう。

## テストのためにプライベートな状態を公開しないこと
テストを行うために、プライベートな状態を公開してはならない。

## テストにドメイン知識を公開しないこと
テストにドメイン知識を漏洩してはならない。
以下のテストでは期待値を得るためにプロダクションコードと同じやり方で計算しているが、
このようなテストはプロダクションコードをテストコードにコピーアンドペーストしているのと何ら変わりがない。
```c#
public static class Calculator
{
	public static int Add(int value1, int value2)
	{
		return value1 + value2;
	}
}

// 間違った方法でのテスト
public class CalculatorTests
{
	// 2つの数値を足す
	[Fact]
	public void Adding_two_numbers()
	{
		int value1 = 1;
		int value2 = 3;
		// ドメイン知識の漏洩
		int expected = value1 + value2;

		int actual = Calculator.Add(value1, value2);

		Assert.Equal(expected, actual);
	}
}
```

## テストのためのコードをプロダクションコードに加えないこと
テストでのみ必要とされるコードをプロダクションコードに加えてはならない。これはプロダクションコードの保守コストを増やしてしまう。

## 既存機能を使うために具象クラスをテストダブルにしないこと
既存の機能をそのまま使えるようにするために具象クラスをテストダブルの対象にしてはならない。この場合、そのクラスを分割した方が良い。

## 静的メソッドで現在日時を渡さないこと
環境コンテキスト(staticなメソッド経由)で現在日時を渡してはならない。明示的な依存として現在日時の値を渡すのが良い。