## インデックスとは？
DBにおけるデータはディスク内に散らばっているため探しづらい。
インデックスは、データがどこにあるかの目印。

例えば、Aliceを探したいとき、インデックスがあれば一撃。
![[DB_インデックス.jpg]]

## インデックスの特徴
### インデックスが効果的なケース
- 完全一致（`name = 'apple'`）
- 範囲検索（`age between 42 and 89`）
- 前方一致（`name like 'w%'`）
完全一致（`name = 'apple'`）はすぐ見つけられる。
![[DB_インデックス_完全一致.jpg]]
インデックスのリーフノードは隣の場所がわかるようになっている。
なので、範囲検索（`age between 42 and 89`）も速い。
![[DB_インデックス_範囲検索.jpg]]
前方一致（`name like 'w%'`）も速い。
### インデックスの効果が薄いケース
- 部分一致(`name like '%i%'`)
- 後方一致(`name like '%e'`)
- 否定検索（`name <> 'apple'`）
インデックスは対象のデータを文字順で並べているので、
後方一致(`name like '%e'`)だと全部に聞いて回る必要がある。
![[DB_インデックス_後方一致.jpg]]
否定検索（`name <> 'apple'`）も、ほぼ全検索になってしまうので遅い。
### 複数のインデックスを同時には使えない
1つのテーブルに複数インデックスを作ることは可能だが、
1度の検索にそれらを同時に使うことはできない。

### インデックスがあると更新が遅くなってしまう
インデックスがあると検索は早くなるが、その代わり更新が遅くなる。
なぜなら、データだけを更新してインデックスを更新しないと対応関係が壊れるので、
データもインデックスも両方更新する必要があるため。
![[DB_インデックス_更新.jpg]]

## 効果的なインデックスの作り方
### カーディナリティが高いといい
検索したときの結果が少ないと
「カーディナリティが高い」といえる。
性別で検索するとたくさん引っかかるが、
![[DB_インデックス_カーディナリティ1.jpg]]
誕生日で検索すると結果が少ないのでカーディナリティが高い。
このようなインデックスは効果が大きい。
![[DB_インデックス_カーディナリティ2.jpg]]
### 複合インデックスのコツ
複合インデックスでは先に候補を大きく絞り込めるようにするのがよい。
例えば、以下のような`血液型-名前`と`名前-血液型`のインデックスを考える。
![[DB_インデックス_複合インデックス.jpg]]
このとき、`B 型 AND Sarah`を探そうとすると、当然名前で先に絞った方が候補を減らせる。
![[DB_インデックス_複合インデックス2.jpg]]
このように、候補をがっつり減らせるところから効かせるのがコツ。

## 参考
[図解 DB インデックス (zenn.dev)](https://zenn.dev/suzuki_hoge/books/2022-12-database-index-9520da88d02c4f)
