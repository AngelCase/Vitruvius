## 概要
「与えられた配列に対して、次の順列を返せ」という問題の解き方について。

例えば、`arr = [1,2,3]`があったとき、以下は全ての`arr`の順列である。
`[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]`

なので、以下のような回答が求められる。
- `arr = [1,2,3]`の次の順列は`[1,3,2]`。
- `arr = [2,3,1]`の次の順列は`[3,1,2]`。
ただし、最後の順列の場合最初に戻る。
- `arr = [3,2,1]`の次の順列は`[1,2,3]`

## 閃き
順列を並べてみても解に至るのは難しく、
アルゴリズムを覚えるのが一番早い。

右から順に見ていって、
「最後の順列」でない部分配列か確認していく。
「途中の順列」だったら、左端を次の順列で左端に来る要素と入れ替えて、
「最初の順列」となるようひっくり返せば次の順列が得られる。
```c
例：
[1,2,4,3]なら[2,4,3]は「最後」じゃない。
↓
[2,4,3]の次を作るなら、左端は3であるべき。
↓
[3,4,2]として、[4,2]をひっくり返す。
↓
[1,3,2,4]
```

## 解き方
右から部分配列を広げながら見ていき、
その部分配列が「最後の順列」でなくなるタイミングを探す。
```c
（例）
配列：[1,3,4,3,2]
[3,2]     → 最後の順列
[4,3,2]   → 最後の順列
[3,4,3,2] → 最後の順列ではない
```

ここで、「最後の順列」でなくなったときに追加された要素を「ピボット」と呼ぶ。

部分配列から、ピボットより大きい中で最も小さい要素を探し、ピボットと入れ替える。
すると、この部分配列は「最後の順列」になる。
```c
（例）
ピボット：3
部分配列：[4,3,2]
3より大きい要素のうち最小は4なので入れ替えると
4 [3,3,2]
```

この順序をひっくり返すと「最初の順列」が得られる。
他の部分配列とくっつければ、次の順列が得られる。
```c
（例）
[3,3,2] → [2,3,3]
1,4 [3,3,2]
答え：[1,4,2,3,3]
```

### ソースコード
```cpp
void nextPermutation(vector<int> &nums)
{
	for (int i = nums.size() - 2; 0 <= i; --i)
	{
		// 右から順番に桁を増やしながら見ていき、
		// 「最後の順列」ではない場所を探す
		if (nums[i] < nums[i + 1])
		{
			// ピボットより大きく、かつ最小を探す
			// 右から順に大きくなるので右から見ればよい
			int swapIdx = nums.size() - 1;
			while (nums[swapIdx] <= nums[i])
			{
				swapIdx--;
			}

			// ピボットと発見した数字を入れ替え
			swap(nums[i], nums[swapIdx]);

			// 「右から順に大きくなる」という性質は維持されている
			// だから反転すれば「最初の順列」が得られる
			reverse(nums.begin() + (i + 1), nums.end());

			return;
		}
	}

	reverse(nums.begin(), nums.end());
}
```

## 別解：STLを使う
```cpp
void nextPermutation(vector<int> &nums)
{
	if (next_permutation(nums.begin(), nums.end()))
	{
		return;
	}

	sort(nums.begin(), nums.end());
}
```
 
## 関連
[Next Permutation - LeetCode](https://leetcode.com/problems/next-permutation/)
