## なぜ所有権が必要なのか
二重解放が行われるとエラーの原因となる。
なぜなら、解放されたアドレスに別のデータを書き込んでいるのに、そこを解放してしまう可能性があるから。
そのため、二重解放を防ぐために所有権の概念が用意された。
所有権者は解放の責務を持つ。

## 所有権のムーブ
ヒープ領域に置かれたリソースには所有権の概念があり、さらに特定のタイミングで所有権のムーブが発生する。
ムーブが発生するのは以下のタイミング：
### 他の変数への代入時
```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{} {}", s1, s2);
// コンパイルエラー！
```

### 関数に引数として渡した時
```rust
let s1 = String::from("hello");
take_ownership(s1);
println!("{}", s1);
// コンパイルエラー！
...
fn take_ownership(s: String) {
    println!("{}", s)
// 出力：hello
}
```
これだと、毎回引数に渡すたびに値がムーブされて使えなくなる。
再利用したければ戻り値としてムーブしなおす必要があるがめんどくさい。
その場合、参照を使うことで負荷を軽減できる。
参考：[[Rust_参照と借用]]

### 関数から値を返す時
```rust
let s1 = String::from("hello");
let s1 = take_giveback(s1);
println!("{}", s1);
// 出力：hello
...
fn take_giveback(s: String) -> String {
	// sの所有権がムーブされる
    s
}
```

一方、スタック領域に置かれたリソースの場合、ムーブではなくコピーが行われる。
```rust
let i0 = 1;
let i1 = i1;
println!("{} {}", i0, i2);
// 出力：1 1
```
