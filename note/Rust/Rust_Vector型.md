## 概要
要素数の変えられない配列と違って、`Vector`型では動的に要素数を変更できる。

```rust
let mut v1 = vec![1, 2, 3, 4];

v1.insert(1, 10);
println!("{:?}", v1);
// 出力：[1, 10, 2, 3, 4]

v1.remove(0);
println!("{:?}", v1);
// 出力：[10, 2, 3, 4]
```

## データ構造
![[Rust_Vector型.png]]
細かい話になってしまうが、このデータ構造を見ると型の情報がないことに気づく。
そのため、`i32`以外の型が入っている場合どうなるのか？という当然の疑問が生まれるが、
厳密にいうと`ptr`にはデータの先頭アドレスだけでなく型の情報も含まれているため、
`i32`以外の型も問題なく扱える。

## 要素を読む
ベクタの値にアクセスするには、2つの方法がある。
添え字記法と`get`メソッドである：
```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
	//                      "3つ目の要素は{}です"
	Some(third) => println!("The third element is {}", third),
	//               "3つ目の要素はありません。"
	None => println!("There is no third element."),
}
```
`[]`メソッドで範囲外の要素にアクセスするとプログラムはパニックする。
`get`だと、パニックせずに`None`を返す。

## 順に処理する
`for`で各要素への不変な参照を手に入れられる。
```rust
let v = vec![100, 32, 57];
for i in &v {
	println!("{}", i);
}
```
変更を加える場合は`mut`をつける。
可変参照の参照値を変更するには、参照外し演算子（`*`）を使う必要がある。
```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
	*i += 50;
}
```

## ベクタを連結する
ベクタを連結する`append()`の注意点として、引数側のVectorの要素が移動されてなくなってしまう点に注意。
```rust
let mut v1 = vec![1, 2, 3, 4];
let mut v2 = vec![9, 10];

v1.append(&mut v2);
println!("{:?}", v1);
// 出力：[1, 2, 3, 4, 9, 10]
println!("{:?}", v2);
// 出力：[]
```
