## 文字列スライス
スライスはコレクション全体ではなく、その中の一連の要素を参照できる。
型は`&str`と記述する。
```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```
以下の例だと、文字列リテラルはバイナリに埋め込まれているので
`s`はバイナリの位置を指すスライスとなる。
```rust
let s = "Hello, world!";
```
### 範囲記法..
`[スライスの最初..スライスの最後より1大きい値]`のような書き方をすることで、範囲を指定したスライスを作れる。
最初の番号から始める場合、2連ピリオドの前を省略可能：
```rust
// これらは等価
let slice = &s[0..2];
let slice = &s[..2];
```
`String`の最後のバイトを含むなら、後ろを省略可能：
```rust
// これらは等価
let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];
```
両方省略すれば全体のスライスが得られる：
```rust
// これらは等価
let len = s.len();

let slice = &s[0..len];
let slice = &s[..];
```

### データ構造
スタック領域に「実データの先頭アドレス」と「サイズ」が保存されている。
実際の文字列は**静的領域**に保存されている。
![[Rust_文字列スライス.png]]
実データは静的領域に保存されているため、動的に要素数を変えることはできない。

## String型
```rust
let mut str = String::from("hello");
str.push_str("_new");
println!("{}", str);
// 出力：hello_new
```
### データ構造
スタック領域に「実データの先頭アドレス」と「サイズ」、「キャパシティ（サイズの限界値）」が保存されている。
実際の文字列は**ヒープ領域**に保存されている。
![[Rust_String型.png]]
実データはヒープ領域に保存されているため、動的に値を変更可能。
その他のポイントとして、こちらは実データを**所有**している点に注意。