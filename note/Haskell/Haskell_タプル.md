## リストとの違い
リストと似ているが、根本的な違いがある。

リストは1つの要素だろうが無限の要素だろうが気にせず、
数が入っていれば「数のリスト」である。

だがタプルでは値の数が正確にわかっていなければ使えず、
その型は含まれるコンポーネントの数と型によって型が決まる。

タプルの方が制約をかけられる、という点で使い道がある。
例えば、2次元座標を格納するリストを作る場合、
タプルは便利である。
```haskell
ghci> [(1,2),(3,4)]
[(1,2),(3,4)]
```
タプルなら、
2次元座標のリストに3次元座標を入れようとしたときに
エラーにできる。
```haskell
ghci> [(1,2),(3,4,5)]
Couldn't match expected type: (a, b)
with actual type: (a0, b0, c0)
```

## タプルを扱う関数
`fst`はペアをとり、最初のコンポーネントを返す。
```haskell
ghci> fst (8,11)
8
ghci> fst ("Wow", False)
"Wow"
```
`snd`は2番目のコンポーネントを返す。
```haskell
ghci> snd (8,11)
11
ghci> snd ("Wow", False)
False
```
これらはもちろん3つ組以上のタプルではな動作しない。

`zip`は2つのリストをとり、
それらの対応する要素をタプルにまとめて1つのリストにする。
```haskell
ghci> zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```
リストの長さが短い場合、余った要素は捨てられる。
なので、例えば無限のリストも扱える。
```haskell
ghci> zip [1..] ["apple","orange"]
[(1,"apple"),(2,"orange")]
```
