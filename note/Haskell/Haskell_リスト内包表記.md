## リスト内包表記
集合の内包的表記のように、Haskellではリスト内包表記を使える。
（参考：[[集合_外延的表記_内包的表記]]）
```haskell
ghci> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```
`|`の右側が既存の集合、左側が新しく作る集合を意味する。

## 条件
条件を加えることもできる。
```haskell
ghci> [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
```
さらなる例として、受け取ったリストに以下の処理を加える関数を作る。
- 10未満の奇数は"BOOM!"
- 10以上の奇数は"BANG!"
- 偶数は捨てる
```haskell
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
```
なお、関数`odd`は奇数の数字だと`True`を返す。
実行結果：
```haskell
ghci> boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"]
```

## 複数の条件
条件を複数にすることもできる。
例えば、10から20の数のうち、13、15、19でないものを取り出す。
```haskell
ghci> [x | x <- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]
```

## 複数のリスト
条件だけでなく、リストも複数とることができる。

複数リストをとる場合、そのすべての組み合わせを生成し、
出力関数によってそれらを結合する。
そのため、長さ4のリストを2つ渡した場合、
長さ16のリストが出力される。

例えば、`[2,5,10]`と`[8,10,11]`の2つのリストがあり、
可能なすべての組み合わせの積を出力する。
```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
```
予想通り、出力されるリストの長さは9である。

さらに、積が50より大きいという条件をつける。
```haskell
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]
[55,80,100,110]
```

## 応用：`length`を自作する
```haskell
length' xs = sum [1 | _ <- xs]
```
なお、`_`はリストの要素がなんであるかを気にせず、その変数を使わないことを示す。

リストの要素の中身は無視して1に置き換え、それを`sum`している。

## 応用：文字列から小文字を消す
```haskell
removeNonUpperCase st = [c | c <- st, c `elem` ['A'..'Z']]
```
なお、`elem`は要素がリストにあるか否かを返す関数。

実行結果：
```haskell
ghci> removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci> removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS"
```

## 応用：ネストされたリストに対する内包表記
```haskell
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```
